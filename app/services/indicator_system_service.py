# app/services/indicator_system_service.py
"""
ÊåáÊ†á‰ΩìÁ≥ªÂª∫ËÆæÊúçÂä°Â±Ç
Â§ÑÁêÜÊåáÊ†á‰ΩìÁ≥ªÁöÑ‰∏öÂä°ÈÄªËæë
"""
from typing import List, Optional, Dict, Any, Tuple
from sqlalchemy import select, and_, or_, func, desc
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload
from loguru import logger
from datetime import datetime
import openpyxl
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from io import BytesIO

from app.models.indicator_system import IndicatorSystem, IndicatorAssetRelation
from app.models.data_asset import DataAsset
from app.schemas.indicator_system import (
    IndicatorSystemCreate, IndicatorSystemUpdate,
    IndicatorAssetRelationCreate, IndicatorStatistics
)


class IndicatorSystemService:
    """ÊåáÊ†á‰ΩìÁ≥ªÊúçÂä°Á±ª"""

    # ExcelÊ®°ÊùøË°®Â§¥ÂÆö‰πâÔºà‰∏≠ÊñáÂêçÔºâ
    EXCEL_HEADERS_CN = [
        "Êù•Ê∫êÁ≥ªÁªü", "‰∏öÂä°È¢ÜÂüü", "‰∏öÂä°‰∏ªÈ¢ò", "ÊåáÊ†áÁ±ªÂà´", "ÊåáÊ†áÂêçÁß∞", "ÊåáÊ†áËØ¥Êòé", "Â§áÊ≥®",
        "ÊåáÊ†áÁ±ªÂûã", "Êï∞ÊçÆÊ†áÂáÜÊäÄÊúØÂàÜÁ±ª", "Êï∞ÊçÆÁ±ªÂûã", "Êï∞ÊçÆÈïøÂ∫¶", "Êï∞ÊçÆÊ†ºÂºè",
        "ÊùÉË¥£ÈÉ®Èó®", "ÈááÈõÜÈ¢ëÁéá", "ÈááÈõÜÊó∂ÁÇπ", "ÂÖ±‰∫´Á±ªÂûã", "ÂºÄÊîæÂ±ûÊÄß"
    ]

    # ExcelÊ®°ÊùøË°®Â§¥ÂÆö‰πâÔºàËã±ÊñáÂ≠óÊÆµÂêçÔºâ
    EXCEL_HEADERS_EN = [
        "source_system", "business_domain", "business_theme", "indicator_category",
        "indicator_name", "indicator_description", "remark",
        "indicator_type", "tech_classification", "data_type", "data_length", "data_format",
        "responsible_dept", "collection_frequency", "collection_time", "share_type", "open_attribute"
    ]

    async def create_indicator(
            self,
            db: AsyncSession,
            indicator_data: IndicatorSystemCreate,
            creator: Optional[str] = None
    ) -> IndicatorSystem:
        """
        ÂàõÂª∫ÊåáÊ†á

        Args:
            db: Êï∞ÊçÆÂ∫ì‰ºöËØù
            indicator_data: ÊåáÊ†áÂàõÂª∫Êï∞ÊçÆ
            creator: ÂàõÂª∫‰∫∫

        Returns:
            ÂàõÂª∫ÁöÑÊåáÊ†áÂØπË±°
        """
        try:
            # ÂàõÂª∫ÊåáÊ†áÂØπË±°
            indicator = IndicatorSystem(
                source_system=indicator_data.source_system,
                business_domain=indicator_data.business_domain,
                business_theme=indicator_data.business_theme,
                indicator_category=indicator_data.indicator_category,
                indicator_name=indicator_data.indicator_name,
                indicator_description=indicator_data.indicator_description,
                remark=indicator_data.remark,
                indicator_type=indicator_data.indicator_type,
                tech_classification=indicator_data.tech_classification,
                data_type=indicator_data.data_type,
                data_length=indicator_data.data_length,
                data_format=indicator_data.data_format,
                responsible_dept=indicator_data.responsible_dept,
                collection_frequency=indicator_data.collection_frequency,
                collection_time=indicator_data.collection_time,
                share_type=indicator_data.share_type,
                open_attribute=indicator_data.open_attribute,
                tags=indicator_data.tags,
                is_active=True,
                created_by=creator,
                updated_by=creator
            )

            db.add(indicator)
            await db.commit()
            await db.refresh(indicator)

            logger.info(f"ÂàõÂª∫ÊåáÊ†áÊàêÂäü: {indicator.indicator_name} (ID: {indicator.id})")
            return indicator

        except Exception as e:
            await db.rollback()
            logger.error(f"ÂàõÂª∫ÊåáÊ†áÂ§±Ë¥•: {e}")
            raise ValueError(f"ÂàõÂª∫ÊåáÊ†áÂ§±Ë¥•: {str(e)}")

    async def get_indicator_by_id(
            self,
            db: AsyncSession,
            indicator_id: int,
            load_relations: bool = False
    ) -> Optional[IndicatorSystem]:
        """
        Ê†πÊçÆIDËé∑ÂèñÊåáÊ†á

        Args:
            db: Êï∞ÊçÆÂ∫ì‰ºöËØù
            indicator_id: ÊåáÊ†áID
            load_relations: ÊòØÂê¶Âä†ËΩΩÂÖ≥ËÅîÁöÑËµÑ‰∫ß

        Returns:
            ÊåáÊ†áÂØπË±°Ôºå‰∏çÂ≠òÂú®ËøîÂõûNone
        """
        try:
            query = select(IndicatorSystem).where(IndicatorSystem.id == indicator_id)

            if load_relations:
                query = query.options(
                    selectinload(IndicatorSystem.asset_relations)
                )

            result = await db.execute(query)
            return result.scalar_one_or_none()

        except Exception as e:
            logger.error(f"Ëé∑ÂèñÊåáÊ†áÂ§±Ë¥•: {e}")
            return None

    async def update_indicator(
            self,
            db: AsyncSession,
            indicator_id: int,
            indicator_data: IndicatorSystemUpdate,
            updater: Optional[str] = None
    ) -> IndicatorSystem:
        """
        Êõ¥Êñ∞ÊåáÊ†á

        Args:
            db: Êï∞ÊçÆÂ∫ì‰ºöËØù
            indicator_id: ÊåáÊ†áID
            indicator_data: Êõ¥Êñ∞Êï∞ÊçÆ
            updater: Êõ¥Êñ∞‰∫∫

        Returns:
            Êõ¥Êñ∞ÂêéÁöÑÊåáÊ†áÂØπË±°

        Raises:
            ValueError: ÊåáÊ†á‰∏çÂ≠òÂú®
        """
        try:
            # Ëé∑ÂèñÊåáÊ†á
            indicator = await self.get_indicator_by_id(db, indicator_id)
            if not indicator:
                raise ValueError(f"ÊåáÊ†á ID {indicator_id} ‰∏çÂ≠òÂú®")

            # Êõ¥Êñ∞Â≠óÊÆµ
            update_data = indicator_data.model_dump(exclude_unset=True)
            for field, value in update_data.items():
                setattr(indicator, field, value)

            indicator.updated_by = updater

            await db.commit()
            await db.refresh(indicator)

            logger.info(f"Êõ¥Êñ∞ÊåáÊ†áÊàêÂäü: {indicator.indicator_name} (ID: {indicator.id})")
            return indicator

        except ValueError:
            raise
        except Exception as e:
            await db.rollback()
            logger.error(f"Êõ¥Êñ∞ÊåáÊ†áÂ§±Ë¥•: {e}")
            raise ValueError(f"Êõ¥Êñ∞ÊåáÊ†áÂ§±Ë¥•: {str(e)}")

    async def delete_indicator(
            self,
            db: AsyncSession,
            indicator_id: int,
            force: bool = False
    ) -> bool:
        """
        Âà†Èô§ÊåáÊ†á

        Args:
            db: Êï∞ÊçÆÂ∫ì‰ºöËØù
            indicator_id: ÊåáÊ†áID
            force: ÊòØÂê¶Âº∫Âà∂Âà†Èô§ÔºàÁâ©ÁêÜÂà†Èô§ÔºâÔºåÂê¶ÂàôËΩØÂà†Èô§

        Returns:
            ÊòØÂê¶Âà†Èô§ÊàêÂäü

        Raises:
            ValueError: ÊåáÊ†á‰∏çÂ≠òÂú®
        """
        try:
            # Ëé∑ÂèñÊåáÊ†á
            indicator = await self.get_indicator_by_id(db, indicator_id)
            if not indicator:
                raise ValueError(f"ÊåáÊ†á ID {indicator_id} ‰∏çÂ≠òÂú®")

            # Âà†Èô§ÊåáÊ†á
            if force:
                # Áâ©ÁêÜÂà†Èô§Ôºà‰ºöÁ∫ßËÅîÂà†Èô§ÂÖ≥ËÅîÂÖ≥Á≥ªÔºâ
                await db.delete(indicator)
            else:
                # ËΩØÂà†Èô§Ôºà‰øÆÊîπÁä∂ÊÄÅÔºâ
                indicator.is_active = False

            await db.commit()

            logger.info(f"Âà†Èô§ÊåáÊ†áÊàêÂäü: {indicator.indicator_name} (ID: {indicator.id}, force={force})")
            return True

        except ValueError:
            raise
        except Exception as e:
            await db.rollback()
            logger.error(f"Âà†Èô§ÊåáÊ†áÂ§±Ë¥•: {e}")
            raise ValueError(f"Âà†Èô§ÊåáÊ†áÂ§±Ë¥•: {str(e)}")

    async def search_indicators(
            self,
            db: AsyncSession,
            page: int = 1,
            page_size: int = 20,
            keyword: Optional[str] = None,
            business_domain: Optional[str] = None,
            business_theme: Optional[str] = None,
            indicator_category: Optional[str] = None,
            indicator_type: Optional[str] = None,
            responsible_dept: Optional[str] = None,
            collection_frequency: Optional[str] = None,
            is_active: Optional[bool] = None
    ) -> Tuple[List[IndicatorSystem], int]:
        """ÊêúÁ¥¢ÊåáÊ†áÔºàÂàÜÈ°µÔºâ"""
        try:
            # ÊûÑÂª∫Êü•ËØ¢Êù°‰ª∂
            conditions = []

            if keyword:
                keyword_pattern = f"%{keyword}%"
                conditions.append(
                    or_(
                        IndicatorSystem.indicator_name.like(keyword_pattern),
                        IndicatorSystem.indicator_description.like(keyword_pattern),
                        IndicatorSystem.source_system.like(keyword_pattern)
                    )
                )

            if business_domain:
                conditions.append(IndicatorSystem.business_domain == business_domain)

            if business_theme:
                conditions.append(IndicatorSystem.business_theme == business_theme)

            if indicator_category:
                conditions.append(IndicatorSystem.indicator_category == indicator_category)

            if indicator_type:
                conditions.append(IndicatorSystem.indicator_type == indicator_type)

            if responsible_dept:
                conditions.append(IndicatorSystem.responsible_dept == responsible_dept)

            if collection_frequency:
                conditions.append(IndicatorSystem.collection_frequency == collection_frequency)

            if is_active is not None:
                conditions.append(IndicatorSystem.is_active == is_active)

            # Êü•ËØ¢ÊÄªÊï∞
            count_query = select(func.count(IndicatorSystem.id))
            if conditions:
                count_query = count_query.where(and_(*conditions))

            count_result = await db.execute(count_query)
            total = count_result.scalar()

            # Êü•ËØ¢Êï∞ÊçÆ
            query = select(IndicatorSystem)
            if conditions:
                query = query.where(and_(*conditions))

            # üÜï Ê∑ªÂä†È¢ÑÂä†ËΩΩ
            query = query.options(selectinload(IndicatorSystem.asset_relations))

            query = query.order_by(desc(IndicatorSystem.created_at))
            query = query.offset((page - 1) * page_size).limit(page_size)

            result = await db.execute(query)
            indicators = result.scalars().all()

            return list(indicators), total

        except Exception as e:
            logger.error(f"ÊêúÁ¥¢ÊåáÊ†áÂ§±Ë¥•: {e}")
            return [], 0

    async def link_assets(
            self,
            db: AsyncSession,
            indicator_id: int,
            asset_ids: List[int],
            relation_type: str = "source",
            relation_description: Optional[str] = None,
            creator: Optional[str] = None
    ) -> List[IndicatorAssetRelation]:
        """
        ÂÖ≥ËÅîÊï∞ÊçÆËµÑ‰∫ßÂà∞ÊåáÊ†á

        Args:
            db: Êï∞ÊçÆÂ∫ì‰ºöËØù
            indicator_id: ÊåáÊ†áID
            asset_ids: ËµÑ‰∫ßIDÂàóË°®
            relation_type: ÂÖ≥ËÅîÁ±ªÂûã
            relation_description: ÂÖ≥ËÅîËØ¥Êòé
            creator: ÂàõÂª∫‰∫∫

        Returns:
            ÂàõÂª∫ÁöÑÂÖ≥ËÅîÂÖ≥Á≥ªÂàóË°®

        Raises:
            ValueError: ÊåáÊ†á‰∏çÂ≠òÂú®ÊàñËµÑ‰∫ß‰∏çÂ≠òÂú®
        """
        try:
            # È™åËØÅÊåáÊ†áÊòØÂê¶Â≠òÂú®
            indicator = await self.get_indicator_by_id(db, indicator_id)
            if not indicator:
                raise ValueError(f"ÊåáÊ†á ID {indicator_id} ‰∏çÂ≠òÂú®")

            # È™åËØÅËµÑ‰∫ßÊòØÂê¶Â≠òÂú®
            assets_query = select(DataAsset).where(DataAsset.id.in_(asset_ids))
            assets_result = await db.execute(assets_query)
            assets = assets_result.scalars().all()

            if len(assets) != len(asset_ids):
                raise ValueError("ÈÉ®ÂàÜÊï∞ÊçÆËµÑ‰∫ß‰∏çÂ≠òÂú®")

            # ÂàõÂª∫ÂÖ≥ËÅîÂÖ≥Á≥ª
            relations = []
            for i, asset_id in enumerate(asset_ids):
                # Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®ÂÖ≥ËÅî
                existing_query = select(IndicatorAssetRelation).where(
                    and_(
                        IndicatorAssetRelation.indicator_id == indicator_id,
                        IndicatorAssetRelation.asset_id == asset_id
                    )
                )
                existing_result = await db.execute(existing_query)
                existing = existing_result.scalar_one_or_none()

                if existing:
                    logger.warning(f"ÂÖ≥ËÅîÂ∑≤Â≠òÂú®: ÊåáÊ†á{indicator_id} - ËµÑ‰∫ß{asset_id}")
                    continue

                relation = IndicatorAssetRelation(
                    indicator_id=indicator_id,
                    asset_id=asset_id,
                    relation_type=relation_type,
                    relation_description=relation_description,
                    sort_order=i,
                    created_by=creator
                )
                db.add(relation)
                relations.append(relation)

            await db.commit()

            logger.info(f"ÂÖ≥ËÅîËµÑ‰∫ßÊàêÂäü: ÊåáÊ†á{indicator_id} ÂÖ≥ËÅî‰∫Ü {len(relations)} ‰∏™ËµÑ‰∫ß")
            return relations

        except ValueError:
            raise
        except Exception as e:
            await db.rollback()
            logger.error(f"ÂÖ≥ËÅîËµÑ‰∫ßÂ§±Ë¥•: {e}")
            raise ValueError(f"ÂÖ≥ËÅîËµÑ‰∫ßÂ§±Ë¥•: {str(e)}")

    async def unlink_asset(
            self,
            db: AsyncSession,
            indicator_id: int,
            asset_id: int
    ) -> bool:
        """
        Ëß£Èô§ÊåáÊ†á‰∏éËµÑ‰∫ßÁöÑÂÖ≥ËÅî

        Args:
            db: Êï∞ÊçÆÂ∫ì‰ºöËØù
            indicator_id: ÊåáÊ†áID
            asset_id: ËµÑ‰∫ßID

        Returns:
            ÊòØÂê¶Ëß£Èô§ÊàêÂäü
        """
        try:
            query = select(IndicatorAssetRelation).where(
                and_(
                    IndicatorAssetRelation.indicator_id == indicator_id,
                    IndicatorAssetRelation.asset_id == asset_id
                )
            )
            result = await db.execute(query)
            relation = result.scalar_one_or_none()

            if not relation:
                raise ValueError(f"ÂÖ≥ËÅîÂÖ≥Á≥ª‰∏çÂ≠òÂú®")

            await db.delete(relation)
            await db.commit()

            logger.info(f"Ëß£Èô§ÂÖ≥ËÅîÊàêÂäü: ÊåáÊ†á{indicator_id} - ËµÑ‰∫ß{asset_id}")
            return True

        except Exception as e:
            await db.rollback()
            logger.error(f"Ëß£Èô§ÂÖ≥ËÅîÂ§±Ë¥•: {e}")
            raise ValueError(f"Ëß£Èô§ÂÖ≥ËÅîÂ§±Ë¥•: {str(e)}")

    async def get_linked_assets(
            self,
            db: AsyncSession,
            indicator_id: int
    ) -> List[Dict[str, Any]]:
        """
        Ëé∑ÂèñÊåáÊ†áÂÖ≥ËÅîÁöÑÊâÄÊúâËµÑ‰∫ß

        Args:
            db: Êï∞ÊçÆÂ∫ì‰ºöËØù
            indicator_id: ÊåáÊ†áID

        Returns:
            ÂÖ≥ËÅîÁöÑËµÑ‰∫ßÂàóË°®
        """
        try:
            query = select(IndicatorAssetRelation).where(
                IndicatorAssetRelation.indicator_id == indicator_id
            ).options(
                selectinload(IndicatorAssetRelation.asset)
            ).order_by(IndicatorAssetRelation.sort_order)

            result = await db.execute(query)
            relations = result.scalars().all()

            assets_list = []
            for relation in relations:
                if relation.asset:
                    assets_list.append({
                        "relation_id": relation.id,
                        "asset_id": relation.asset_id,
                        "asset_name": relation.asset.asset_name,
                        "asset_code": relation.asset.asset_code,
                        "table_name": relation.asset.table_name,
                        "relation_type": relation.relation_type,
                        "relation_description": relation.relation_description,
                        "sort_order": relation.sort_order
                    })

            return assets_list

        except Exception as e:
            logger.error(f"Ëé∑ÂèñÂÖ≥ËÅîËµÑ‰∫ßÂ§±Ë¥•: {e}")
            return []

    async def batch_create_indicators(
            self,
            db: AsyncSession,
            indicators_data: List[IndicatorSystemCreate],
            creator: Optional[str] = None
    ) -> Tuple[List[IndicatorSystem], List[Dict[str, Any]]]:
        """
        ÊâπÈáèÂàõÂª∫ÊåáÊ†á

        Args:
            db: Êï∞ÊçÆÂ∫ì‰ºöËØù
            indicators_data: ÊåáÊ†áÂàõÂª∫Êï∞ÊçÆÂàóË°®
            creator: ÂàõÂª∫‰∫∫

        Returns:
            (ÊàêÂäüÂàõÂª∫ÁöÑÊåáÊ†áÂàóË°®, Â§±Ë¥•ÁöÑÈ°πÁõÆÂàóË°®)
        """
        success_indicators = []
        failed_items = []

        for idx, indicator_data in enumerate(indicators_data):
            try:
                indicator = await self.create_indicator(db, indicator_data, creator)
                success_indicators.append(indicator)
            except Exception as e:
                failed_items.append({
                    "row": idx + 1,
                    "indicator_name": indicator_data.indicator_name,
                    "error": str(e)
                })
                logger.warning(f"ÊâπÈáèÂàõÂª∫Á¨¨ {idx + 1} Êù°Â§±Ë¥•: {e}")

        return success_indicators, failed_items

    def generate_excel_template(self) -> BytesIO:
        """
        ÁîüÊàêExcelÂØºÂÖ•Ê®°Êùø

        Returns:
            ExcelÊñá‰ª∂ÁöÑBytesIOÂØπË±°
        """
        try:
            # ÂàõÂª∫Â∑•‰ΩúÁ∞ø
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = "ÊåáÊ†á‰ΩìÁ≥ªÊ®°Êùø"

            # Ê†∑ÂºèÂÆö‰πâ
            header_font = Font(name='ÂæÆËΩØÈõÖÈªë', size=11, bold=True, color='FFFFFF')
            header_fill = PatternFill(start_color='4472C4', end_color='4472C4', fill_type='solid')
            header_alignment = Alignment(horizontal='center', vertical='center')
            border = Border(
                left=Side(style='thin'),
                right=Side(style='thin'),
                top=Side(style='thin'),
                bottom=Side(style='thin')
            )

            # Á¨¨‰∏ÄË°åÔºö‰∏≠ÊñáË°®Â§¥
            for col_idx, header in enumerate(self.EXCEL_HEADERS_CN, start=1):
                cell = ws.cell(row=1, column=col_idx)
                cell.value = header
                cell.font = header_font
                cell.fill = header_fill
                cell.alignment = header_alignment
                cell.border = border

            # Á¨¨‰∫åË°åÔºöËã±ÊñáÂ≠óÊÆµÂêçÔºàÁÅ∞Ëâ≤ËÉåÊôØÔºâ
            field_font = Font(name='Consolas', size=9, color='666666')
            field_fill = PatternFill(start_color='E7E6E6', end_color='E7E6E6', fill_type='solid')

            for col_idx, field in enumerate(self.EXCEL_HEADERS_EN, start=1):
                cell = ws.cell(row=2, column=col_idx)
                cell.value = field
                cell.font = field_font
                cell.fill = field_fill
                cell.alignment = Alignment(horizontal='left', vertical='center')
                cell.border = border

            # Á¨¨‰∏âË°åÔºöÁ§∫‰æãÊï∞ÊçÆ
            example_data = [
                "CRMÁ≥ªÁªü", "ÂÆ¢Êà∑ÁÆ°ÁêÜ", "ÂÆ¢Êà∑ÂàÜÊûê", "Âü∫Á°ÄÊåáÊ†á", "ÂÆ¢Êà∑ÊÄªÊï∞",
                "ÁªüËÆ°ÊâÄÊúâÊ≥®ÂÜåÂÆ¢Êà∑ÁöÑÊÄªÊï∞Èáè", "Ê†∏ÂøÉÊåáÊ†á",
                "Á¥ØËÆ°ÂÄº", "Êï∞ÂÄºÁ±ª", "INTEGER", "10", "Êï¥Êï∞",
                "Â∏ÇÂú∫ÈÉ®", "ÊØèÊó•", "23:59", "ÂÆåÂÖ®ÂÖ±‰∫´", "ÂØπÂ§ñÂºÄÊîæ"
            ]

            for col_idx, value in enumerate(example_data, start=1):
                cell = ws.cell(row=3, column=col_idx)
                cell.value = value
                cell.border = border

            # ËÆæÁΩÆÂàóÂÆΩ
            column_widths = [15, 15, 15, 15, 25, 30, 20, 15, 20, 15, 12, 15, 15, 15, 15, 15, 15]
            for idx, width in enumerate(column_widths, start=1):
                ws.column_dimensions[openpyxl.utils.get_column_letter(idx)].width = width

            # ÂÜªÁªìÂâç‰∏§Ë°å
            ws.freeze_panes = 'A3'

            # ‰øùÂ≠òÂà∞BytesIO
            output = BytesIO()
            wb.save(output)
            output.seek(0)

            logger.info("ÁîüÊàêExcelÊ®°ÊùøÊàêÂäü")
            return output

        except Exception as e:
            logger.error(f"ÁîüÊàêExcelÊ®°ÊùøÂ§±Ë¥•: {e}")
            raise ValueError(f"ÁîüÊàêExcelÊ®°ÊùøÂ§±Ë¥•: {str(e)}")

    async def import_from_excel(
            self,
            db: AsyncSession,
            file_content: bytes,
            creator: Optional[str] = None
    ) -> Tuple[List[IndicatorSystem], List[Dict[str, Any]]]:
        """‰ªéExcelÂØºÂÖ•ÊåáÊ†áÔºàÂ∏¶ÈáçÂ§çÊ£ÄÊµãÔºâ"""
        success_indicators = []
        failed_rows = []
        BATCH_SIZE = 100

        try:
            wb = openpyxl.load_workbook(BytesIO(file_content))
            ws = wb.active

            indicators_batch = []

            # üÜï Áî®‰∫éÊ£ÄÊµãÈáçÂ§çÁöÑÈõÜÂêà
            seen_indicators = set()

            # üÜï ‰ªéÊï∞ÊçÆÂ∫ìÂä†ËΩΩÂ∑≤Â≠òÂú®ÁöÑÊåáÊ†áÂêçÁß∞
            existing_query = select(IndicatorSystem.indicator_name).where(
                IndicatorSystem.is_active == True
            )
            existing_result = await db.execute(existing_query)
            existing_names = {row[0] for row in existing_result}

            for row_idx, row in enumerate(ws.iter_rows(min_row=3, values_only=True), start=3):
                try:
                    if not any(row):
                        continue

                    indicator_name = row[4] if row[4] else f"Êú™ÂëΩÂêçÊåáÊ†á_{row_idx}"

                    # üÜï Ê£ÄÊü•ExcelÂÜÖÈÉ®ÈáçÂ§ç
                    if indicator_name in seen_indicators:
                        failed_rows.append({
                            "row": row_idx,
                            "data": list(row) if row else [],
                            "error": f"ÊåáÊ†áÂêçÁß∞ÈáçÂ§çÔºàExcelÂÜÖÔºâ: {indicator_name}"
                        })
                        continue

                    # üÜï Ê£ÄÊü•Êï∞ÊçÆÂ∫ì‰∏≠Â∑≤Â≠òÂú®
                    if indicator_name in existing_names:
                        failed_rows.append({
                            "row": row_idx,
                            "data": list(row) if row else [],
                            "error": f"ÊåáÊ†áÂêçÁß∞Â∑≤Â≠òÂú®‰∫éÊï∞ÊçÆÂ∫ì: {indicator_name}"
                        })
                        continue

                    seen_indicators.add(indicator_name)

                    indicator = IndicatorSystem(
                        source_system=row[0] if row[0] else None,
                        business_domain=row[1] if row[1] else None,
                        business_theme=row[2] if row[2] else None,
                        indicator_category=row[3] if row[3] else None,
                        indicator_name=indicator_name,
                        indicator_description=row[5] if row[5] else None,
                        remark=row[6] if row[6] else None,
                        indicator_type=row[7] if row[7] else None,
                        tech_classification=row[8] if row[8] else None,
                        data_type=row[9] if row[9] else None,
                        data_length=int(row[10]) if row[10] and str(row[10]).replace('.', '').replace('-',
                                                                                                      '').isdigit() else None,
                        data_format=row[11] if row[11] else None,
                        responsible_dept=row[12] if row[12] else None,
                        collection_frequency=row[13] if row[13] else None,
                        collection_time=row[14] if row[14] else None,
                        share_type=row[15] if row[15] else None,
                        open_attribute=row[16] if row[16] else None,
                        is_active=True,
                        created_by=creator,
                        updated_by=creator
                    )

                    indicators_batch.append(indicator)

                    # ÊØè100Êù°Êèê‰∫§‰∏ÄÊ¨°
                    if len(indicators_batch) >= BATCH_SIZE:
                        try:
                            db.add_all(indicators_batch)
                            await db.commit()

                            for ind in indicators_batch:
                                await db.refresh(ind)
                                success_indicators.append(ind)
                                existing_names.add(ind.indicator_name)  # üÜï Êõ¥Êñ∞Â∑≤Â≠òÂú®ÈõÜÂêà

                            logger.info(f"Â∑≤ÂØºÂÖ• {len(success_indicators)} Êù°")
                            indicators_batch = []

                        except Exception as e:
                            await db.rollback()
                            logger.error(f"ÊâπÊ¨°ÂØºÂÖ•Â§±Ë¥•: {e}")
                            for ind in indicators_batch:
                                failed_rows.append({
                                    "row": row_idx,
                                    "data": [ind.indicator_name],
                                    "error": str(e)
                                })
                            indicators_batch = []

                except Exception as e:
                    failed_rows.append({
                        "row": row_idx,
                        "data": list(row) if row else [],
                        "error": str(e)
                    })

            # Êèê‰∫§Ââ©‰ΩôÁöÑÊï∞ÊçÆ
            if indicators_batch:
                try:
                    db.add_all(indicators_batch)
                    await db.commit()

                    for ind in indicators_batch:
                        await db.refresh(ind)
                        success_indicators.append(ind)

                except Exception as e:
                    await db.rollback()
                    logger.error(f"ÊúÄÂêéÊâπÊ¨°ÂØºÂÖ•Â§±Ë¥•: {e}")
                    for ind in indicators_batch:
                        failed_rows.append({
                            "row": -1,
                            "data": [ind.indicator_name],
                            "error": str(e)
                        })

            logger.info(f"ExcelÂØºÂÖ•ÂÆåÊàê: ÊàêÂäü {len(success_indicators)}ÔºåÂ§±Ë¥• {len(failed_rows)}")
            return success_indicators, failed_rows

        except Exception as e:
            logger.error(f"Ëß£ÊûêExcelÂ§±Ë¥•: {e}")
            raise ValueError(f"Ëß£ÊûêExcelÂ§±Ë¥•: {str(e)}")

    def export_to_excel(self, indicators: List[IndicatorSystem]) -> BytesIO:
        """
        Â∞ÜÊåáÊ†áÊï∞ÊçÆÂØºÂá∫‰∏∫Excel
        """
        try:
            if indicators:
                first = indicators[0]
                logger.info(f"Á¨¨‰∏ÄÊù°Êï∞ÊçÆÁ±ªÂûãÊ£ÄÊü•:")
                logger.info(f"source_system: {type(first.source_system)} = {first.source_system}")
                logger.info(f"business_domain: {type(first.business_domain)} = {first.business_domain}")
            # ÂàõÂª∫Â∑•‰ΩúÁ∞ø
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = "ÊåáÊ†áÊï∞ÊçÆ"

            # Ê†∑ÂºèÂÆö‰πâ
            header_font = Font(name='ÂæÆËΩØÈõÖÈªë', size=11, bold=True, color='FFFFFF')
            header_fill = PatternFill(start_color='4472C4', end_color='4472C4', fill_type='solid')
            header_alignment = Alignment(horizontal='center', vertical='center')
            border = Border(
                left=Side(style='thin'),
                right=Side(style='thin'),
                top=Side(style='thin'),
                bottom=Side(style='thin')
            )

            # ÂÜôÂÖ•Ë°®Â§¥
            for col_idx, header in enumerate(self.EXCEL_HEADERS_CN, start=1):
                cell = ws.cell(row=1, column=col_idx)
                cell.value = header
                cell.font = header_font
                cell.fill = header_fill
                cell.alignment = header_alignment
                cell.border = border

            # ÂÜôÂÖ•Êï∞ÊçÆ
            for row_idx, indicator in enumerate(indicators, start=2):
                data_row = [
                    str(indicator.source_system) if indicator.source_system else '',
                    str(indicator.business_domain) if indicator.business_domain else '',
                    str(indicator.business_theme) if indicator.business_theme else '',
                    str(indicator.indicator_category) if indicator.indicator_category else '',
                    str(indicator.indicator_name) if indicator.indicator_name else '',
                    str(indicator.indicator_description) if indicator.indicator_description else '',
                    str(indicator.remark) if indicator.remark else '',
                    str(indicator.indicator_type) if indicator.indicator_type else '',
                    str(indicator.tech_classification) if indicator.tech_classification else '',
                    str(indicator.data_type) if indicator.data_type else '',
                    str(indicator.data_length) if indicator.data_length is not None else '',
                    str(indicator.data_format) if indicator.data_format else '',
                    str(indicator.responsible_dept) if indicator.responsible_dept else '',
                    str(indicator.collection_frequency) if indicator.collection_frequency else '',
                    str(indicator.collection_time) if indicator.collection_time else '',
                    str(indicator.share_type) if indicator.share_type else '',
                    str(indicator.open_attribute) if indicator.open_attribute else ''
                ]

                for col_idx, value in enumerate(data_row, start=1):
                    cell = ws.cell(row=row_idx, column=col_idx)
                    cell.value = value  # valueÂ∑≤ÁªèÊòØÂ≠óÁ¨¶‰∏≤‰∫Ü
                    cell.border = border

            # ËÆæÁΩÆÂàóÂÆΩ
            column_widths = [15, 15, 15, 20, 25, 30, 20, 15, 20, 15, 12, 15, 15, 15, 25, 15, 15]
            for idx, width in enumerate(column_widths, start=1):
                ws.column_dimensions[openpyxl.utils.get_column_letter(idx)].width = width

            # ‰øùÂ≠òÂà∞BytesIO
            output = BytesIO()
            wb.save(output)
            output.seek(0)

            logger.info(f"ÂØºÂá∫ExcelÊàêÂäüÔºåÂÖ± {len(indicators)} Êù°Êï∞ÊçÆ")
            return output

        except Exception as e:
            logger.error(f"ÂØºÂá∫ExcelÂ§±Ë¥•: {e}")
            raise ValueError(f"ÂØºÂá∫ExcelÂ§±Ë¥•: {str(e)}")


    async def get_statistics(self, db: AsyncSession) -> IndicatorStatistics:
        """
        Ëé∑ÂèñÊåáÊ†áÁªüËÆ°‰ø°ÊÅØ

        Args:
            db: Êï∞ÊçÆÂ∫ì‰ºöËØù

        Returns:
            ÁªüËÆ°‰ø°ÊÅØ
        """
        try:
            # ÊÄªÊï∞
            total_query = select(func.count(IndicatorSystem.id))
            total_result = await db.execute(total_query)
            total_count = total_result.scalar()

            # ÂêØÁî®Êï∞
            active_query = select(func.count(IndicatorSystem.id)).where(
                IndicatorSystem.is_active == True
            )
            active_result = await db.execute(active_query)
            active_count = active_result.scalar()

            # Êåâ‰∏öÂä°È¢ÜÂüüÁªüËÆ°
            domain_query = select(
                IndicatorSystem.business_domain,
                func.count(IndicatorSystem.id)
            ).where(
                IndicatorSystem.business_domain.isnot(None)
            ).group_by(IndicatorSystem.business_domain)
            domain_result = await db.execute(domain_query)
            by_domain = {row[0]: row[1] for row in domain_result}

            # ÊåâÊåáÊ†áÁ±ªÂà´ÁªüËÆ°
            category_query = select(
                IndicatorSystem.indicator_category,
                func.count(IndicatorSystem.id)
            ).where(
                IndicatorSystem.indicator_category.isnot(None)
            ).group_by(IndicatorSystem.indicator_category)
            category_result = await db.execute(category_query)
            by_category = {row[0]: row[1] for row in category_result}

            # ÊåâÈááÈõÜÈ¢ëÁéáÁªüËÆ°
            frequency_query = select(
                IndicatorSystem.collection_frequency,
                func.count(IndicatorSystem.id)
            ).where(
                IndicatorSystem.collection_frequency.isnot(None)
            ).group_by(IndicatorSystem.collection_frequency)
            frequency_result = await db.execute(frequency_query)
            by_frequency = {row[0]: row[1] for row in frequency_result}

            return IndicatorStatistics(
                total_count=total_count,
                active_count=active_count,
                inactive_count=total_count - active_count,
                by_domain=by_domain,
                by_category=by_category,
                by_frequency=by_frequency
            )

        except Exception as e:
            logger.error(f"Ëé∑ÂèñÁªüËÆ°‰ø°ÊÅØÂ§±Ë¥•: {e}")
            return IndicatorStatistics(
                total_count=0,
                active_count=0,
                inactive_count=0,
                by_domain={},
                by_category={},
                by_frequency={}
            )

    async def get_all_business_domains(self, db: AsyncSession) -> List[str]:
        """Ëé∑ÂèñÊâÄÊúâ‰∏öÂä°È¢ÜÂüüÔºàÂéªÈáçÔºâ"""
        try:
            query = select(IndicatorSystem.business_domain).where(
                IndicatorSystem.business_domain.isnot(None)
            ).distinct().order_by(IndicatorSystem.business_domain)

            result = await db.execute(query)
            return [row[0] for row in result]
        except Exception as e:
            logger.error(f"Ëé∑Âèñ‰∏öÂä°È¢ÜÂüüÂàóË°®Â§±Ë¥•: {e}")
            return []

    async def get_all_indicator_categories(self, db: AsyncSession) -> List[str]:
        """Ëé∑ÂèñÊâÄÊúâÊåáÊ†áÁ±ªÂà´ÔºàÂéªÈáçÔºâ"""
        try:
            query = select(IndicatorSystem.indicator_category).where(
                IndicatorSystem.indicator_category.isnot(None)
            ).distinct().order_by(IndicatorSystem.indicator_category)

            result = await db.execute(query)
            return [row[0] for row in result]
        except Exception as e:
            logger.error(f"Ëé∑ÂèñÊåáÊ†áÁ±ªÂà´ÂàóË°®Â§±Ë¥•: {e}")
            return []


# ÂàõÂª∫ÂÖ®Â±ÄÊúçÂä°ÂÆû‰æã
indicator_system_service = IndicatorSystemService()